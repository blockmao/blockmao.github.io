<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.blockmao.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Netty：编解码">
<meta property="og:url" content="http://blog.blockmao.cn/posts/32223.html">
<meta property="og:site_name" content="牛觅博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/20210411121331image-20210411121330879.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/370a9d9ea83d4d6aa0d617b765040728~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abcf92322644495b812c0298eac89065~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/314bf6d6e7d843f3973e9106fdbd1e18~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecaedb84e0c4c3bbe76cebf74ca3252~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/344220c8d3774af9884c46c008ce4d02~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc466dc2a1f4edba380edeb6c7bdbe8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57dee8598704e7db752a1d16f1fc4a8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6243cb44d8f4ace9f33ff8a670d20a0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b91a99ef5254ef8b7180a74296cb97c~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe16cdb8864514a8cb5dd4b05d8008~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bfd611e8af942d1b4f802311573e3b4~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078baeef36e14b7b92d85d1fb9e73f44~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e578d6dca16b4d97a2c385f5ca37ce28~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac7370668b44a4aa05d007f927054c9~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2021-04-11T04:08:51.000Z">
<meta property="article:modified_time" content="2021-04-15T09:42:36.684Z">
<meta property="article:author" content="牛觅">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/niumi/drawing/raw/master/20210411121331image-20210411121330879.png">

<link rel="canonical" href="http://blog.blockmao.cn/posts/32223.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Netty：编解码 | 牛觅博客</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a83b1fd818b3df8c1797aa2a2bb38b3e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛觅博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.blockmao.cn/posts/32223.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="牛觅">
      <meta itemprop="description" content="温故知新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛觅博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty：编解码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 12:08:51" itemprop="dateCreated datePublished" datetime="2021-04-11T12:08:51+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-15 17:42:36" itemprop="dateModified" datetime="2021-04-15T17:42:36+08:00">2021-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://gitee.com/niumi/drawing/raw/master/20210411121331image-20210411121330879.png" alt="image-20210411121330879"></p>
<span id="more"></span>

<h1 id="为什么有拆包 - 粘包？"><a href="# 为什么有拆包 - 粘包？" class="headerlink" title="为什么有拆包 / 粘包？"></a>为什么有拆包 / 粘包？</h1><p>TCP 传输协议是面向流的，没有数据包界限。客户端向服务端发送数据时，可能将一个完整的报文拆分成多个小报文进行发送，也可能将多个报文合并成一个大的报文进行发送。因此就有了拆包和粘包。</p>
<p>为什么会出现拆包 / 粘包现象呢？</p>
<p>在网络通信的过程中，每次可以发送的数据包大小是受多种因素限制的，如 <strong>MTU 传输单元大小 </strong>、<strong>MSS 最大分段大小</strong>、<strong> 滑动窗口 </strong> 等。如果一次传输的网络包数据大小超过传输单元大小，那么数据可能会拆分为多个数据包发送出去。如果每次请求的网络包数据都很小，一共请求了 10000 次，TCP 并不会分别发送 10000 次。因为 TCP 采用的 Nagle 算法对此作出了优化。</p>
<h2 id="MTU 最大传输单元和 MSS 最大分段大小"><a href="#MTU 最大传输单元和 MSS 最大分段大小" class="headerlink" title="MTU 最大传输单元和 MSS 最大分段大小"></a>MTU 最大传输单元和 MSS 最大分段大小</h2><p><strong>MTU（Maxitum Transmission Unit</strong>） 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。如下图所示，MTU 和 MSS 一般的计算关系为：MSS = MTU - IP 首部 - TCP 首部，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是拆包现象。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/370a9d9ea83d4d6aa0d617b765040728~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h2 id="滑动窗口"><a href="# 滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口 </h2><p><strong> 滑动窗口 </strong> 是 TCP 传输层用于流量控制的一种有效措施，也被称为 <strong> 通告窗口</strong>。滑动窗口是数据接收方设置的窗口大小，随后接收方会把窗口大小告诉发送方，以此限制发送方每次发送数据的大小，从而达到流量控制的目的。这样数据发送方不需要每发送一组数据就阻塞等待接收方确认，允许发送方同时发送多个数据分组，每次发送的数据都会被限制在窗口大小内。由此可见，滑动窗口可以大幅度提升网络吞吐量。</p>
<p>那么 TCP 报文是怎么确保数据包按次序到达且不丢数据呢？首先，所有的数据帧都是有编号的，TCP 并不会为每个报文段都回复 ACK 响应，它会对多个报文段回复一次 ACK。假设有三个报文段 A、B、C，发送方先发送了 B、C，接收方则必须等待 A 报文段到达，如果一定时间内仍未等到 A 报文段，那么 B、C 也会被丢弃，发送方会发起重试。如果已接收到 A 报文段，那么将会回复发送方一次 ACK 确认。</p>
<h2 id="Nagle 算法"><a href="#Nagle 算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法 </h2><p><strong>Nagle 算法</strong> 于 1984 年被福特航空和通信公司定义为<strong>TCP/IP 拥塞控制方法</strong>。它主要用于解决频繁发送小数据包而带来的网络拥塞问题。试想如果每次需要发送的数据只有 1 字节，加上 20 个字节 IP  Header 和 20 个字节 TCP Header，每次发送的数据包大小为 41 字节，但是只有 1 字节是有效信息，这就造成了非常大的浪费。</p>
<p>Nagle 算法可以理解为 <strong> 批量发送</strong>，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。</p>
<p>Linux 在默认情况下是开启 Nagle 算法的，在大量小数据包的场景下可以有效地降低网络开销。但如果你的业务场景每次发送的数据都需要获得及时响应，那么 Nagle 算法就不能满足你的需求了，因为 Nagle 算法会有一定的数据延迟。你可以通过 Linux 提供的 <code>TCP_NODELAY</code> 参数禁用 Nagle 算法。Netty 中为了使数据传输延迟最小化，就默认禁用了 Nagle 算法，这一点与 Linux 操作系统的默认行为是相反的。</p>
<h1 id="拆包 - 粘包的解决方案"><a href="# 拆包 - 粘包的解决方案" class="headerlink" title="拆包 / 粘包的解决方案"></a>拆包 / 粘包的解决方案</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abcf92322644495b812c0298eac89065~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。如上图所示，拆包 / 粘包可能会出现以下五种情况：</p>
<ul>
<li>服务端恰巧读到了两个完整的数据包 A 和 B，没有出现拆包 / 粘包问题；</li>
<li>服务端接收到 A 和 B 粘在一起的数据包，服务端需要解析出 A 和 B；</li>
<li>服务端收到完整的 A 和 B 的一部分数据包 B-1，服务端需要解析出完整的 A，并等待读取完整的 B 数据包；</li>
<li>服务端接收到 A 的一部分数据包 A-1，此时需要等待接收到完整的 A 数据包；</li>
<li>数据包 A 较大，服务端需要多次才可以接收完数据包 A。</li>
</ul>
<p>由于拆包 / 粘包问题的存在，数据接收方很难界定数据包的边界在哪里，很难识别出一个完整的数据包。所以需要提供一种机制来识别数据包的界限，这也是解决拆包 / 粘包的唯一方法：<strong>定义应用层的通信协议</strong>。</p>
<h2 id="主流协议的解决方案"><a href="# 主流协议的解决方案" class="headerlink" title="主流协议的解决方案"></a>主流协议的解决方案 </h2><h3 id="消息长度固定"><a href="# 消息长度固定" class="headerlink" title="消息长度固定"></a> 消息长度固定 </h3><p> 每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/314bf6d6e7d843f3973e9106fdbd1e18~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>假设我们的固定长度为 4 字节，那么如上所示的 5 条数据一共需要发送 4 个报文：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecaedb84e0c4c3bbe76cebf74ca3252~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>消息定长法使用非常简单，但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用。</p>
<h3 id="特定分隔符"><a href="# 特定分隔符" class="headerlink" title="特定分隔符"></a><strong>特定分隔符 </strong></h3><p> 在每次发送报文的尾部加上 <strong> 特定分隔符 </strong>，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符<code>\n</code> 按行解析，即可得到 AB、CDEF、GHIJ、K、LM 五条原始报文。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/344220c8d3774af9884c46c008ce4d02~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>由于在发送报文时尾部需要添加特定分隔符，所以对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。否则可能出现错误的消息拆分。比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。特定分隔符法在消息协议足够简单的场景下比较高效，例如大名鼎鼎的 Redis 在通信过程中采用的就是换行分隔符。</p>
<h3 id="消息长度 - 消息内容"><a href="# 消息长度 - 消息内容" class="headerlink" title="消息长度 + 消息内容"></a><strong>消息长度 + 消息内容</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc466dc2a1f4edba380edeb6c7bdbe8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><strong>消息长度 + 消息内容 </strong> 是项目开发中最常用的一种协议，如上展示了该协议的基本格式。消息头中存放消息的总长度，例如使用 4 字节的 int 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 Len，然后紧接着读取长度为 Len 的字节数据，该数据即判定为一个完整的数据报文。依然以上述提到的原始字节数据为例，使用该协议进行编码后的结果如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57dee8598704e7db752a1d16f1fc4a8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。</p>
<h1 id="通信协议设计"><a href="# 通信协议设计" class="headerlink" title="通信协议设计"></a>通信协议设计 </h1><p> 所谓协议，就是通信双方事先商量好的接口暗语，在 TCP 网络编程中，发送方和接收方的数据包格式都是二进制，发送方将对象转化成二进制流发送给接收方，接收方获得二进制数据后需要知道如何解析成对象，所以协议是 <strong> 双方能够正常通信的基础</strong>。</p>
<h2 id="通用协议"><a href="# 通用协议" class="headerlink" title="通用协议"></a>通用协议 </h2><p> 目前市面上已经有不少通用的协议，例如 HTTP、HTTPS、JSON-RPC、FTP、IMAP、Protobuf 等。<strong>通用协议 </strong> 兼容性好，易于维护，各种异构系统之间可以实现无缝对接。如果在满足业务场景以及性能需求的前提下，推荐采用通用协议的方案。</p>
<p>相比通用协议，自定义协议主要有以下优点：</p>
<ul>
<li><strong>极致性能</strong>：通用的通信协议考虑了很多兼容性的因素，必然在性能方面有所损失。</li>
<li><strong>扩展性</strong>：自定义的协议相比通用协议更好扩展，可以更好地满足自己的业务需求。</li>
<li><strong>安全性</strong>：通用协议是公开的，很多漏洞已经很多被黑客攻破。自定义协议更加安全，因为黑客需要先破解你的协议内容。</li>
</ul>
<h2 id="自定义通信协议"><a href="# 自定义通信协议" class="headerlink" title="自定义通信协议"></a>自定义通信协议 </h2><p> 那么如何设计自定义的通信协议呢？这个答案见仁见智，但是设计通信协议有经验方法可循。结合实战经验我们一起看下一个完备的网络协议需要具备哪些基本要素。</p>
<h3 id="1- 魔数"><a href="#1- 魔数" class="headerlink" title="1. 魔数"></a><strong>1. 魔数 </strong></h3><p> 魔数是通信双方协商的一个暗号，通常采用固定的几个字节表示。魔数的作用是 <strong> 防止任何人随便向服务器的端口上发送数据</strong>。服务端在接收到数据时会解析出前几个固定字节的魔数，然后做正确性比对。如果和约定的魔数不匹配，则认为是非法数据，可以直接关闭连接或者采取其他措施以增强系统的安全防护。</p>
<p>魔数的思想在压缩算法、Java Class 文件等场景中都有所体现，例如 Class 文件开头就存储了魔数 0xCAFEBABE，在加载 Class 文件时首先会验证魔数的正确性。</p>
<h3 id="2- 协议版本号"><a href="#2- 协议版本号" class="headerlink" title="2. 协议版本号"></a><strong>2. 协议版本号 </strong></h3><p> 随着业务需求的变化，协议可能需要对结构或字段进行改动，不同版本的协议对应的解析方法也是不同的。所以在生产级项目中强烈建议预留 <strong> 协议版本号 </strong> 这个字段。</p>
<h3 id="3- 序列化算法"><a href="#3- 序列化算法" class="headerlink" title="3. 序列化算法"></a><strong>3. 序列化算法 </strong></h3><p> 序列化算法字段表示数据发送方应该采用何种方法将请求的对象转化为二进制，以及如何再将二进制转化为对象，如 JSON、Hessian、Java 自带序列化等。</p>
<h3 id="4- 报文类型"><a href="#4- 报文类型" class="headerlink" title="4. 报文类型"></a><strong>4. 报文类型 </strong></h3><p> 在不同的业务场景中，报文可能存在不同的类型。例如在 RPC 框架中有请求、响应、心跳等类型的报文，在 IM 即时通信的场景中有登陆、创建群聊、发送消息、接收消息、退出群聊等类型的报文。</p>
<h3 id="5- 长度域字段"><a href="#5- 长度域字段" class="headerlink" title="5. 长度域字段"></a><strong>5. 长度域字段 </strong></h3><p> 长度域字段代表请求数据的长度，接收方根据长度域字段获取一个完整的报文。</p>
<h3 id="6- 请求数据"><a href="#6- 请求数据" class="headerlink" title="6. 请求数据"></a><strong>6. 请求数据 </strong></h3><p> 请求数据通常为序列化之后得到的二进制流，每种请求数据的内容是不一样的。</p>
<h3 id="7- 状态"><a href="#7- 状态" class="headerlink" title="7. 状态"></a><strong>7. 状态 </strong></h3><p> 状态字段用于标识请求是否正常。一般由被调用方设置。例如一次 RPC 调用失败，状态字段可被服务提供方设置为异常状态。</p>
<h3 id="8- 保留字段"><a href="#8- 保留字段" class="headerlink" title="8. 保留字段"></a><strong>8. 保留字段 </strong></h3><p> 保留字段是可选项，为了应对协议升级的可能性，可以预留若干字节的保留字段，以备不时之需。</p>
<hr>
<p>通过以上协议基本要素的学习，可以得到一个较为通用的协议示例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6243cb44d8f4ace9f33ff8a670d20a0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="Netty 如何实现自定义通信协议"><a href="#Netty 如何实现自定义通信协议" class="headerlink" title="Netty 如何实现自定义通信协议"></a>Netty 如何实现自定义通信协议</h2><p>Netty 作为一个非常优秀的网络通信框架，已经为我们提供了非常丰富的编解码抽象基类，帮助我们更方便地基于这些抽象基类扩展实现自定义协议。</p>
<p>首先我们看下 Netty 中编解码器是如何分类的。</p>
<p><strong>Netty 常用编码器类型</strong>：</p>
<ul>
<li><code>MessageToByteEncoder</code> 对象编码成字节流；</li>
<li><code>MessageToMessageEncoder</code> 一种消息类型编码成另外一种消息类型。</li>
</ul>
<p><strong>Netty 常用解码器类型</strong>：</p>
<ul>
<li><code>ByteToMessageDecoder/ReplayingDecoder</code> 将字节流解码为消息对象；</li>
<li><code>MessageToMessageDecoder</code> 将一种消息类型解码为另外一种消息类型。</li>
</ul>
<p>编解码器可以分为 <strong> 一次解码器和二次解码器</strong>，一次解码器用于解决 TCP 拆包 / 粘包问题，按协议解析后得到的字节数据。如果你需要对解析后的字节数据做对象模型的转换，这时候便需要用到二次解码器，同理编码器的过程是反过来的。</p>
<ul>
<li><strong>一次编解码器</strong>：<code>MessageToByteEncoder/ByteToMessageDecoder</code>。</li>
<li><strong>二次编解码器</strong>：<code>MessageToMessageEncoder/MessageToMessageDecoder</code>。</li>
</ul>
<h3 id="抽象编码类"><a href="# 抽象编码类" class="headerlink" title="抽象编码类"></a><strong>抽象编码类 </strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b91a99ef5254ef8b7180a74296cb97c~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 通过抽象编码类的继承图可以看出，编码类是<code>ChannelOutboundHandler</code> 的抽象类实现，具体操作的是 <code>Outbound</code> 出站数据。</p>
<h4 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h4><p>MessageToByteEncoder 用于将对象编码成字节流，MessageToByteEncoder 提供了唯一的 <code>encode</code> 抽象方法，我们只需要实现 <code>encode 方法</code> 即可完成自定义编码。</p>
<p><code>encode()方法 </code> 是在什么时候被调用的呢？我们一起看下 MessageToByteEncoder 的核心源码片段，如下所示。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">    ByteBuf buf = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 消息类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</span><br><span class="line">            <span class="keyword">@SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">            I <span class="keyword">cast</span> = (I) msg;</span><br><span class="line">            <span class="comment">// 2. 分配 ByteBuf 资源</span></span><br><span class="line">            buf = allocateBuffer(ctx, <span class="keyword">cast</span>, preferDirect);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 执行 encode 方法完成数据编码</span></span><br><span class="line">                encode(ctx, <span class="keyword">cast</span>, buf);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ReferenceCountUtil.release(<span class="keyword">cast</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                <span class="comment">// 4. 向后传递写事件</span></span><br><span class="line">                ctx.write(buf, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.release();</span><br><span class="line">                ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            buf = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EncoderException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="literal">null</span>) &#123;</span><br><span class="line">            buf.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageToByteEncoder 重写了 ChanneOutboundHandler 的 write() 方法，其主要逻辑分为以下几个步骤：</p>
<ol>
<li>acceptOutboundMessage 判断是否有匹配的消息类型，如果匹配需要执行编码流程，如果不匹配直接继续传递给下一个 ChannelOutboundHandler；</li>
<li>分配 ByteBuf 资源，默认使用 <strong> 堆外内存</strong>；</li>
<li>调用子类实现的 encode 方法完成数据编码，一旦消息被成功编码，会通过调用 ReferenceCountUtil.release(cast) 自动释放；</li>
<li>如果 ByteBuf 可读，说明已经成功编码得到数据，然后写入 ChannelHandlerContext 交到下一个节点；如果 ByteBuf 不可读，则释放 ByteBuf 资源，向下传递空的 ByteBuf 对象。</li>
</ol>
<p><strong>编码器实现非常简单，不需要关注拆包 / 粘包问题</strong>。如下例子，展示了如何将字符串类型的数据写入到 ByteBuf 实例，ByteBuf 实例将传递给 ChannelPipeline 链表中的下一个 ChannelOutboundHandler。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StringToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder&lt;String&gt;</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> channelHandlerContext, <span class="type">String</span> data, <span class="type">ByteBuf</span> byteBuf) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">            byteBuf.writeBytes(data.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageToMessageEncoder"><a href="#MessageToMessageEncoder" class="headerlink" title="MessageToMessageEncoder"></a>MessageToMessageEncoder</h4><p>MessageToMessageEncoder 与 MessageToByteEncoder 类似，同样只需要实现 encode 方法。与 MessageToByteEncoder 不同的是，MessageToMessageEncoder 是将一种格式的消息转换为另外一种格式的消息。其中第二个 Message 所指的可以是任意一个对象，如果该对象是 ByteBuf 类型，那么基本上和 MessageToByteEncoder 的实现原理是一致的。</p>
<p>此外 MessageToMessageEncoder 的输出结果是对象列表，编码后的结果属于中间对象，最终仍然会转化成 ByteBuf 进行传输。</p>
<p>MessageToMessageEncoder 常用的 <strong> 实现子类 </strong> 有 StringEncoder、LineEncoder、Base64Encoder 等。以 StringEncoder 为例看下 MessageToMessageEncoder 的用法。源码示例如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected <span class="type">void</span> encode(ChannelHandlerContext ctx, CharSequence msg, List&lt;<span class="keyword">Object</span>&gt; <span class="keyword">out</span>) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">out</span>.<span class="keyword">add</span>(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(msg), charset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象解码类"><a href="# 抽象解码类" class="headerlink" title="抽象解码类"></a><strong>抽象解码类 </strong></h3><p> 解码类是 ChanneInboundHandler 的抽象类实现，操作的是 Inbound 入站数据。<strong>解码器实现的难度要远大于编码器，因为解码器需要考虑拆包 / 粘包问题</strong>。由于接收方有可能没有接收到完整的消息，所以解码框架需要对入站的数据做缓冲操作，直至获取到完整的消息。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe16cdb8864514a8cb5dd4b05d8008~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h4 id="抽象解码类 -ByteToMessageDecoder"><a href="# 抽象解码类 -ByteToMessageDecoder" class="headerlink" title="抽象解码类 ByteToMessageDecoder"></a>抽象解码类 ByteToMessageDecoder</h4><p>首先，我们看下 <strong>ByteToMessageDecoder</strong> 定义的抽象方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span>;</span><br><span class="line">    <span class="keyword">protected</span> void decodeLast(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.isReadable()) &#123;</span><br><span class="line">            decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>decode()</code>是用户必须实现的抽象方法，在该方法在调用时需要传入接收的数据 ByteBuf，及用来添加编码后消息的 List。由于 TCP 粘包问题，ByteBuf 中可能包含多个有效的报文，或者不够一个完整的报文。Netty 会重复回调 decode() 方法，直到没有解码出新的完整报文可以添加到 List 当中，或者 ByteBuf 没有更多可读取的数据为止。如果此时 List 的内容不为空，那么会传递给  ChannelPipeline 中的下一个 ChannelInboundHandler。</li>
<li>此外 ByteToMessageDecoder 还定义了 <code>decodeLast()</code> 方法。为什么抽象解码器要比编码器多一个 decodeLast() 方法呢？因为 decodeLast 在 Channel 关闭后会被调用一次，主要用于处理 ByteBuf 最后剩余的字节数据。Netty 中 decodeLast 的默认实现只是简单调用了 decode() 方法。如果有特殊的业务需求，则可以通过重写 decodeLast() 方法扩展自定义逻辑。</li>
<li>ByteToMessageDecoder 还有一个抽象子类是 ReplayingDecoder。它封装了缓冲区的管理，在读取缓冲区数据时，你无须再对字节长度进行检查。因为如果没有足够长度的字节数据，ReplayingDecoder 将终止解码操作。ReplayingDecoder 的性能相比直接使用 ByteToMessageDecoder 要慢，大部分情况下并不推荐使用 ReplayingDecoder。</li>
</ul>
<h4 id="抽象解码类 -MessageToMessageDecoder"><a href="# 抽象解码类 -MessageToMessageDecoder" class="headerlink" title="抽象解码类 MessageToMessageDecoder"></a>抽象解码类 MessageToMessageDecoder</h4><p>MessageToMessageDecoder 与 ByteToMessageDecoder 作用类似，都是将一种消息类型的编码成另外一种消息类型。与 ByteToMessageDecoder 不同的是 MessageToMessageDecoder 并不会对数据报文进行缓存，它主要用作转换消息模型。</p>
<p>比较推荐的做法是使用 ByteToMessageDecoder 解析 TCP 协议，解决拆包 / 粘包问题。解析得到有效的 ByteBuf 数据，然后传递给后续的 MessageToMessageDecoder 做数据对象的转换，具体流程如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bfd611e8af942d1b4f802311573e3b4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="通信协议实战"><a href="# 通信协议实战" class="headerlink" title="通信协议实战"></a>通信协议实战 </h2><p> 在实现协议编码器之前，我们首先需要清楚一个问题：如何判断 ByteBuf 是否存在完整的报文？最常用的做法就是通过读取消息长度 dataLength 进行判断。如果 ByteBuf 的可读数据长度小于 dataLength，说明 ByteBuf 还不够获取一个完整的报文。在该协议前面的消息头部分包含了魔数、协议版本号、数据长度等固定字段，共 14 个字节。固定字段长度和数据长度可以作为我们判断消息完整性的依据，具体编码器实现逻辑示例如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="code">+---------------------------------------------------------------+</span></span><br><span class="line">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span><br><span class="line"><span class="code">+---------------------------------------------------------------+</span></span><br><span class="line">| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | </span><br><span class="line"><span class="code">+---------------------------------------------------------------+</span></span><br><span class="line">|                   数据内容 （长度不定）                          |</span><br><span class="line"><span class="code">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="code"> */</span></span><br><span class="line">@Override</span><br><span class="line">public final void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123;</span><br><span class="line"><span class="code">    // 判断 ByteBuf 可读取字节</span></span><br><span class="line"><span class="code">    if (in.readableBytes() &lt; 14) &#123; </span></span><br><span class="line"><span class="code">        return;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    in.markReaderIndex(); // 标记 ByteBuf 读指针位置</span></span><br><span class="line"><span class="code">    in.skipBytes(2); // 跳过魔数</span></span><br><span class="line"><span class="code">    in.skipBytes(1); // 跳过协议版本号</span></span><br><span class="line"><span class="code">    byte serializeType = in.readByte();</span></span><br><span class="line"><span class="code">    in.skipBytes(1); // 跳过报文类型</span></span><br><span class="line"><span class="code">    in.skipBytes(1); // 跳过状态字段</span></span><br><span class="line"><span class="code">    in.skipBytes(4); // 跳过保留字段</span></span><br><span class="line"><span class="code">    int dataLength = in.readInt();</span></span><br><span class="line"><span class="code">    if (in.readableBytes() &lt; dataLength) &#123;</span></span><br><span class="line"><span class="code">        in.resetReaderIndex(); // 重置 ByteBuf 读指针位置</span></span><br><span class="line"><span class="code">        return;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    byte[] data = new byte[dataLength];</span></span><br><span class="line"><span class="code">    in.readBytes(data);</span></span><br><span class="line"><span class="code">    SerializeService serializeService = getSerializeServiceByType(serializeType);</span></span><br><span class="line"><span class="code">    Object obj = serializeService.deserialize(data);</span></span><br><span class="line"><span class="code">    if (obj != null) &#123;</span></span><br><span class="line"><span class="code">        out.add(obj);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty 常用的解码器"><a href="#Netty 常用的解码器" class="headerlink" title="Netty 常用的解码器"></a>Netty 常用的解码器</h1><p>Netty 提供了很多开箱即用的解码器，这些解码器基本覆盖了 TCP 拆包 / 粘包的通用解决方案。</p>
<h2 id="固定长度解码器 -FixedLengthFrameDecoder"><a href="# 固定长度解码器 -FixedLengthFrameDecoder" class="headerlink" title="固定长度解码器 FixedLengthFrameDecoder"></a>固定长度解码器 FixedLengthFrameDecoder</h2><p>固定长度解码器 FixedLengthFrameDecoder 非常简单，直接通过构造函数设置固定长度的大小 frameLength，无论接收方一次获取多大的数据，都会严格按照 frameLength 进行解码。如果累积读取到长度大小为 frameLength 的消息，那么解码器认为已经获取到了一个完整的消息。如果消息长度小于 frameLength，FixedLengthFrameDecoder 解码器会一直等后续数据包的到达，直至获得完整的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startEchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">10</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer().startEchoServer(<span class="number">8088</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receive client : [&quot;</span> + ((ByteBuf) msg).toString(CharsetUtil.UTF_8) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述服务端的代码中使用了固定 10 字节的解码器，并在解码之后通过 EchoServerHandler 打印结果。我们可以启动服务端，通过 telnet 命令像服务端发送数据，观察代码输出的结果。</p>
<p>客户端输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 8088</span><br><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">1234567890123</span><br><span class="line">456789012</span><br></pre></td></tr></table></figure>

<p>服务端输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Receive client : [1234567890]</span><br><span class="line">Receive client : [123</span><br><span class="line">45678]</span><br></pre></td></tr></table></figure>



<h2 id="特殊分隔符解码器 -DelimiterBasedFrameDecoder"><a href="# 特殊分隔符解码器 -DelimiterBasedFrameDecoder" class="headerlink" title="特殊分隔符解码器 DelimiterBasedFrameDecoder"></a>特殊分隔符解码器 DelimiterBasedFrameDecoder</h2><ul>
<li><p><code>delimiters</code></p>
<p>delimiters 指定特殊分隔符，通过写入 ByteBuf 作为参数传入。delimiters 的类型是 ByteBuf 数组，所以我们可以同时指定多个分隔符，但是最终会选择长度最短的分隔符进行消息拆分。</p>
</li>
<li><p><code>maxLength</code></p>
<p>maxLength 是报文最大长度的限制。如果超过 maxLength 还没有检测到指定分隔符，将会抛出 TooLongFrameException。可以说 maxLength 是对程序在极端情况下的一种保护措施。</p>
</li>
<li><p><code>failFast</code></p>
<p>failFast 与 maxLength 需要搭配使用，通过设置 failFast 可以控制抛出 TooLongFrameException 的时机，可以说 Netty 在细节上考虑得面面俱到。如果 failFast=true，那么在超出 maxLength 会立即抛出 TooLongFrameException，不再继续进行解码。如果 failFast=false，那么会等到解码出一个完整的消息后才会抛出 TooLongFrameException。</p>
</li>
<li><p><code>stripDelimiter</code></p>
<p>stripDelimiter 的作用是判断解码后得到的消息是否去除分隔符。</p>
</li>
</ul>
<p>下面我们还是结合代码示例学习 DelimiterBasedFrameDecoder 的用法，依然以固定编码器小节中使用的代码为基础稍做改动，引入特殊分隔符解码器 DelimiterBasedFrameDecoder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">&quot;&amp;&quot;</span>.getBytes());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">10</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, delimiter));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>我们依然通过 telnet 模拟客户端发送数据，观察代码输出的结果，可以发现由于 maxLength 设置的只有 10，所以在解析到第三个消息时抛出异常。</p>
<p>客户端输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 8088</span><br><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">hello&amp;world&amp;1234567890ab</span><br></pre></td></tr></table></figure>

<p>服务端输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Receive client : [hello]</span><br><span class="line">Receive client : [world]</span><br><span class="line">九月 25, 2020 8:46:01 下午 io.netty.channel.DefaultChannelPipeline onUnhandledInboundException</span><br><span class="line">警告: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.</span><br><span class="line">io.netty.handler.codec.TooLongFrameException: frame length exceeds 10: 13 - discarded</span><br><span class="line">	at io.netty.handler.codec.DelimiterBasedFrameDecoder.fail(DelimiterBasedFrameDecoder.java:302)</span><br><span class="line">	at io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:268)</span><br><span class="line">	at io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:218)</span><br></pre></td></tr></table></figure>

<h2 id="长度域解码器 -LengthFieldBasedFrameDecoder"><a href="# 长度域解码器 -LengthFieldBasedFrameDecoder" class="headerlink" title="长度域解码器 LengthFieldBasedFrameDecoder"></a>长度域解码器 LengthFieldBasedFrameDecoder</h2><p>长度域解码器 LengthFieldBasedFrameDecoder 是解决 TCP 拆包 / 粘包问题最常用的 <strong> 解码器</strong>。它基本上可以覆盖大部分基于长度拆包场景，开源消息中间件 RocketMQ 就是使用 LengthFieldBasedFrameDecoder 进行解码的。</p>
<ul>
<li><code>delimiters</code></li>
</ul>
<p>delimiters 指定特殊分隔符，通过写入 ByteBuf 作为参数传入。delimiters 的类型是 ByteBuf 数组，所以我们可以同时指定多个分隔符，但是最终会选择长度最短的分隔符进行消息拆分。</p>
<ul>
<li><code>maxLength</code></li>
</ul>
<p>maxLength 是报文最大长度的限制。如果超过 maxLength 还没有检测到指定分隔符，将会抛出 TooLongFrameException。可以说 maxLength 是对程序在极端情况下的一种保护措施。</p>
<ul>
<li><code>failFast</code></li>
</ul>
<p>failFast 与 maxLength 需要搭配使用，通过设置 failFast 可以控制抛出 TooLongFrameException 的时机，可以说 Netty 在细节上考虑得面面俱到。如果 failFast=true，那么在超出 maxLength 会立即抛出 TooLongFrameException，不再继续进行解码。如果 failFast=false，那么会等到解码出一个完整的消息后才会抛出 TooLongFrameException。</p>
<ul>
<li><code>stripDelimiter</code></li>
</ul>
<p>stripDelimiter 的作用是判断解码后得到的消息是否去除分隔符。</p>
<p>下面我们还是结合代码示例学习 <code>DelimiterBasedFrameDecoder</code> 的用法，依然以固定编码器小节中使用的代码为基础稍做改动，引入特殊分隔符解码器 DelimiterBasedFrameDecoder：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(<span class="module-access"><span class="module"><span class="identifier">NioServerSocketChannel</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">    .child<span class="constructor">Handler(<span class="params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void init<span class="constructor">Channel(SocketChannel <span class="params">ch</span>)</span> &#123;</span><br><span class="line">            ByteBuf delimiter = <span class="module-access"><span class="module"><span class="identifier">Unpooled</span>.</span></span>copied<span class="constructor">Buffer(<span class="string">&quot;&amp;&quot;</span>.<span class="params">getBytes</span>()</span>);</span><br><span class="line">            ch.pipeline<span class="literal">()</span>.add<span class="constructor">Last(<span class="params">new</span> DelimiterBasedFrameDecoder(10, <span class="params">true</span>, <span class="params">true</span>, <span class="params">delimiter</span>)</span>);</span><br><span class="line">            ch.pipeline<span class="literal">()</span>.add<span class="constructor">Last(<span class="params">new</span> EchoServerHandler()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>我们依然通过 telnet 模拟客户端发送数据，观察代码输出的结果，可以发现由于 maxLength 设置的只有 10，所以在解析到第三个消息时抛出异常。</p>
<p>客户端输入：</p>
<p>服务端输出：</p>
<h3 id="属性说明"><a href="# 属性说明" class="headerlink" title="属性说明"></a><strong>属性说明 </strong></h3><p> 先了解 LengthFieldBasedFrameDecoder 中的几个重要属性，这里我主要把它们分为两个部分：长度域解码器特有属性以及与其他解码器（如特定分隔符解码器）的相似的属性。</p>
<ul>
<li><strong>长度域解码器特有属性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度字段的偏移量，也就是存放长度数据的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthFieldOffset; </span><br><span class="line"><span class="comment">// 长度字段所占用的字节数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthFieldLength; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 消息长度的修正值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在很多较为复杂一些的协议设计中，长度域不仅仅包含消息的长度，而且包含其他的数据，如版本号、数据类型、数据状态等，那么这时候我们需要使用 lengthAdjustment 进行修正</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * lengthAdjustment = 包体的长度值 - 长度域的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthAdjustment; </span><br><span class="line"><span class="comment">// 解码后需要跳过的初始字节数，也就是消息内容字段的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initialBytesToStrip;</span><br><span class="line"><span class="comment">// 长度字段结束的偏移量，lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthFieldEndOffset;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>与固定长度解码器和特定分隔符解码器相似的属性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxFrameLength; <span class="comment">// 报文最大限制长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failFast; <span class="comment">// 是否立即抛出 TooLongFrameException，与 maxFrameLength 搭配使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> discardingTooLongFrame; <span class="comment">// 是否处于丢弃模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> tooLongFrameLength; <span class="comment">// 需要丢弃的字节数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> bytesToDiscard; <span class="comment">// 累计丢弃的字节数</span></span><br></pre></td></tr></table></figure>

<h3 id="示例 -1：典型的基于消息长度 - 消息内容的解码"><a href="# 示例 -1：典型的基于消息长度 - 消息内容的解码" class="headerlink" title="示例 1：典型的基于消息长度 + 消息内容的解码"></a><strong>示例 1：典型的基于消息长度 + 消息内容的解码</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078baeef36e14b7b92d85d1fb9e73f44~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>上述协议是最基本的格式，报文只包含消息长度 Length 和消息内容 Content 字段，其中 Length 为 16 进制表示，共占用 2 字节，Length 的值 0x000C 代表 Content 占用 12 字节。该协议对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 0，因为 Length 字段就在报文的开始位置。</p>
</li>
<li><p>lengthFieldLength = 2，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = 0，Length 字段只包含消息长度，不需要做任何修正。</p>
</li>
<li><p>initialBytesToStrip = 0，解码后内容依然是 Length + Content，不需要跳过任何初始字节。</p>
</li>
</ul>
<h3 id="示例 -2：解码结果需要截断"><a href="# 示例 -2：解码结果需要截断" class="headerlink" title="示例 2：解码结果需要截断"></a><strong>示例 2：解码结果需要截断</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e578d6dca16b4d97a2c385f5ca37ce28~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>示例 2 和示例 1 的区别在于解码后的结果只包含消息内容，其他的部分是不变的。该协议对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 0，因为 Length 字段就在报文的开始位置。</p>
</li>
<li><p>lengthFieldLength = 2，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = 0，Length 字段只包含消息长度，不需要做任何修正。</p>
</li>
<li><p>initialBytesToStrip = 2，跳过 Length 字段的字节长度，解码后 ByteBuf 中只包含 Content 字段。</p>
</li>
</ul>
<h3 id="示例 -3：长度字段包含消息长度和消息内容所占的字节。"><a href="# 示例 -3：长度字段包含消息长度和消息内容所占的字节。" class="headerlink" title="示例 3：长度字段包含消息长度和消息内容所占的字节。"></a><strong>示例 3：长度字段包含消息长度和消息内容所占的字节。</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac7370668b44a4aa05d007f927054c9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>与前两个示例不同的是，示例 3 的 Length 字段包含 Length 字段自身的固定长度以及 Content 字段所占用的字节数，Length 的值为 0x000E（2 + 12 = 14 字节），在 Length 字段值（14 字节）的基础上做 lengthAdjustment（-2）的修正，才能得到真实的 Content 字段长度，所以对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 0，因为 Length 字段就在报文的开始位置。</p>
</li>
<li><p>lengthFieldLength = 2，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = -2，长度字段为 14 字节，需要减 2 才是拆包所需要的长度。</p>
</li>
<li><p>initialBytesToStrip = 0，解码后内容依然是 Length + Content，不需要跳过任何初始字节。</p>
</li>
</ul>
<h3 id="示例 -4：基于长度字段偏移的解码"><a href="# 示例 -4：基于长度字段偏移的解码" class="headerlink" title="示例 4：基于长度字段偏移的解码"></a><strong>示例 4：基于长度字段偏移的解码</strong></h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="line">|<span class="string"> Header 1 </span>|<span class="string">  Length  </span>|<span class="string"> Actual Content </span>|<span class="string">-----&gt;</span>|<span class="string"> Header 1 </span>|<span class="string">  Length  </span>|<span class="string"> Actual Content </span>|</span><br><span class="line">|<span class="string">  0xCAFE  </span>|<span class="string"> 0x00000C </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|<span class="string">      </span>|<span class="string">  0xCAFE  </span>|<span class="string"> 0x00000C </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br></pre></td></tr></table></figure>

<p>示例 4 中 Length 字段不再是报文的起始位置，Length 字段的值为 0x00000C，表示 Content 字段占用 12 字节，该协议对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 2，需要跳过 Header 1 所占用的 2 字节，才是 Length 的起始位置。</p>
</li>
<li><p>lengthFieldLength = 3，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = 0，Length 字段只包含消息长度，不需要做任何修正。</p>
</li>
<li><p>initialBytesToStrip = 0，解码后内容依然是完整的报文，不需要跳过任何初始字节。</p>
</li>
</ul>
<h3 id="示例 -5：长度字段与内容字段不再相邻"><a href="# 示例 -5：长度字段与内容字段不再相邻" class="headerlink" title="示例 5：长度字段与内容字段不再相邻"></a><strong>示例 5：长度字段与内容字段不再相邻</strong></h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="line">|<span class="string">  Length  </span>|<span class="string"> Header 1 </span>|<span class="string"> Actual Content </span>|<span class="string">-----&gt;</span>|<span class="string">  Length  </span>|<span class="string"> Header 1 </span>|<span class="string"> Actual Content </span>|</span><br><span class="line">|<span class="string"> 0x00000C </span>|<span class="string">  0xCAFE  </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|<span class="string">      </span>|<span class="string"> 0x00000C </span>|<span class="string">  0xCAFE  </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br></pre></td></tr></table></figure>

<p>示例 5 中的 Length 字段之后是 Header 1，Length 与 Content 字段不再相邻。Length 字段所表示的内容略过了 Header 1 字段，所以也需要通过 lengthAdjustment 修正才能得到 Header + Content 的内容。示例 5 所对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 0，因为 Length 字段就在报文的开始位置。</p>
</li>
<li><p>lengthFieldLength = 3，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = 2，由于 Header + Content 一共占用 2 + 12 = 14 字节，所以 Length 字段值（12 字节）加上 lengthAdjustment（2 字节）才能得到 Header + Content 的内容（14 字节）。</p>
</li>
<li><p>initialBytesToStrip = 0，解码后内容依然是完整的报文，不需要跳过任何初始字节。</p>
</li>
</ul>
<h3 id="示例 -6：基于长度偏移和长度修正的解码"><a href="# 示例 -6：基于长度偏移和长度修正的解码" class="headerlink" title="示例 6：基于长度偏移和长度修正的解码"></a><strong>示例 6：基于长度偏移和长度修正的解码</strong></h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br><span class="line">|<span class="string"> HDR1 </span>|<span class="string"> Length </span>|<span class="string"> HDR2 </span>|<span class="string"> Actual Content </span>|<span class="string">-----&gt;</span>|<span class="string"> HDR2 </span>|<span class="string"> Actual Content </span>|</span><br><span class="line">|<span class="string"> 0xCA </span>|<span class="string"> 0x000C </span>|<span class="string"> 0xFE </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|<span class="string">      </span>|<span class="string"> 0xFE </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure>

<p>示例 6 中 Length 字段前后分为别 HDR1 和 HDR2 字段，各占用 1 字节，所以既需要做长度字段的偏移，也需要做 lengthAdjustment 修正，具体修正的过程与 示例 5 类似。对应的解码器参数组合如下：</p>
<ul>
<li><p>lengthFieldOffset = 1，需要跳过 HDR1 所占用的 1 字节，才是 Length 的起始位置。</p>
</li>
<li><p>lengthFieldLength = 2，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = 1，由于 HDR2 + Content 一共占用 1 + 12 = 13 字节，所以 Length 字段值（12 字节）加上 lengthAdjustment（1）才能得到 HDR2 + Content 的内容（13 字节）。</p>
</li>
<li><p>initialBytesToStrip = 3，解码后跳过 HDR1 和 Length 字段，共占用 3 字节。</p>
</li>
</ul>
<h3 id="示例 -7：长度字段包含除 -Content- 外的多个其他字段"><a href="# 示例 -7：长度字段包含除 -Content- 外的多个其他字段" class="headerlink" title="示例 7：长度字段包含除 Content 外的多个其他字段"></a><strong>示例 7：长度字段包含除 Content 外的多个其他字段</strong></h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br><span class="line">|<span class="string"> HDR1 </span>|<span class="string"> Length </span>|<span class="string"> HDR2 </span>|<span class="string"> Actual Content </span>|<span class="string">-----&gt;</span>|<span class="string"> HDR2 </span>|<span class="string"> Actual Content </span>|</span><br><span class="line">|<span class="string"> 0xCA </span>|<span class="string"> 0x0010 </span>|<span class="string"> 0xFE </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|<span class="string">      </span>|<span class="string"> 0xFE </span>|<span class="string"> &quot;HELLO, WORLD&quot; </span>|</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure>

<p>示例 7 与 示例 6 的区别在于 Length 字段记录了整个报文的长度，包含 Length 自身所占字节、HDR1 、HDR2 以及 Content 字段的长度，解码器需要知道如何进行 lengthAdjustment 调整，才能得到 HDR2 和 Content 的内容。所以我们可以采用如下的解码器参数组合：</p>
<ul>
<li><p>lengthFieldOffset = 1，需要跳过 HDR1 所占用的 1 字节，才是 Length 的起始位置。</p>
</li>
<li><p>lengthFieldLength = 2，协议设计的固定长度。</p>
</li>
<li><p>lengthAdjustment = -3，Length 字段值（16 字节）需要减去 HDR1（1 字节） 和 Length 自身所占字节长度（2 字节）才能得到 HDR2 和 Content 的内容（1 + 12 = 13 字节）。</p>
</li>
<li><p>initialBytesToStrip = 3，解码后跳过 HDR1 和 Length 字段，共占用 3 字节。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/48830.html" rel="prev" title="JVM：如何处理对象分配、布局和访问？">
      <i class="fa fa-chevron-left"></i> JVM：如何处理对象分配、布局和访问？
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/33835.html" rel="next" title="HBase：基础篇">
      HBase：基础篇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%8B%86%E5%8C%85%20-%20%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">为什么有拆包 &#x2F; 粘包？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MTU%20%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%E5%92%8C%20MSS%20%E6%9C%80%E5%A4%A7%E5%88%86%E6%AE%B5%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.</span> <span class="nav-text">MTU 最大传输单元和 MSS 最大分段大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">滑动窗口 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nagle%20%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">Nagle 算法 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%86%E5%8C%85%20-%20%E7%B2%98%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">拆包 &#x2F; 粘包的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.</span> <span class="nav-text">主流协议的解决方案 </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6%E5%9B%BA%E5%AE%9A"><span class="nav-number">2.1.1.</span> <span class="nav-text"> 消息长度固定 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">2.1.2.</span> <span class="nav-text">特定分隔符 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6%20-%20%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9"><span class="nav-number">2.1.3.</span> <span class="nav-text">消息长度 + 消息内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text">通信协议设计 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.</span> <span class="nav-text">通用协议 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.</span> <span class="nav-text">自定义通信协议 </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%20%E9%AD%94%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 魔数 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%20%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 协议版本号 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%20%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 序列化算法 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%20%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 报文类型 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%20%E9%95%BF%E5%BA%A6%E5%9F%9F%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.5.</span> <span class="nav-text">5. 长度域字段 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.6.</span> <span class="nav-text">6. 请求数据 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%20%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.7.</span> <span class="nav-text">7. 状态 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%20%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.8.</span> <span class="nav-text">8. 保留字段 </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.3.</span> <span class="nav-text">Netty 如何实现自定义通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A0%81%E7%B1%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">抽象编码类 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageToByteEncoder"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">MessageToByteEncoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageToMessageEncoder"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">MessageToMessageEncoder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%A7%A3%E7%A0%81%E7%B1%BB"><span class="nav-number">3.3.2.</span> <span class="nav-text">抽象解码类 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%A7%A3%E7%A0%81%E7%B1%BB%20-ByteToMessageDecoder"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">抽象解码类 ByteToMessageDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%A7%A3%E7%A0%81%E7%B1%BB%20-MessageToMessageDecoder"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">抽象解码类 MessageToMessageDecoder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98"><span class="nav-number">3.4.</span> <span class="nav-text">通信协议实战 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%20%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">Netty 常用的解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E8%A7%A3%E7%A0%81%E5%99%A8%20-FixedLengthFrameDecoder"><span class="nav-number">4.1.</span> <span class="nav-text">固定长度解码器 FixedLengthFrameDecoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%88%86%E9%9A%94%E7%AC%A6%E8%A7%A3%E7%A0%81%E5%99%A8%20-DelimiterBasedFrameDecoder"><span class="nav-number">4.2.</span> <span class="nav-text">特殊分隔符解码器 DelimiterBasedFrameDecoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E5%9F%9F%E8%A7%A3%E7%A0%81%E5%99%A8%20-LengthFieldBasedFrameDecoder"><span class="nav-number">4.3.</span> <span class="nav-text">长度域解码器 LengthFieldBasedFrameDecoder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="nav-number">4.3.1.</span> <span class="nav-text">属性说明 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-1%EF%BC%9A%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6%20-%20%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E7%9A%84%E8%A7%A3%E7%A0%81"><span class="nav-number">4.3.2.</span> <span class="nav-text">示例 1：典型的基于消息长度 + 消息内容的解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-2%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BB%93%E6%9E%9C%E9%9C%80%E8%A6%81%E6%88%AA%E6%96%AD"><span class="nav-number">4.3.3.</span> <span class="nav-text">示例 2：解码结果需要截断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-3%EF%BC%9A%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E5%8C%85%E5%90%AB%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6%E5%92%8C%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E6%89%80%E5%8D%A0%E7%9A%84%E5%AD%97%E8%8A%82%E3%80%82"><span class="nav-number">4.3.4.</span> <span class="nav-text">示例 3：长度字段包含消息长度和消息内容所占的字节。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-4%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E5%81%8F%E7%A7%BB%E7%9A%84%E8%A7%A3%E7%A0%81"><span class="nav-number">4.3.5.</span> <span class="nav-text">示例 4：基于长度字段偏移的解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-5%EF%BC%9A%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%86%8D%E7%9B%B8%E9%82%BB"><span class="nav-number">4.3.6.</span> <span class="nav-text">示例 5：长度字段与内容字段不再相邻</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-6%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E5%81%8F%E7%A7%BB%E5%92%8C%E9%95%BF%E5%BA%A6%E4%BF%AE%E6%AD%A3%E7%9A%84%E8%A7%A3%E7%A0%81"><span class="nav-number">4.3.7.</span> <span class="nav-text">示例 6：基于长度偏移和长度修正的解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%20-7%EF%BC%9A%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E5%8C%85%E5%90%AB%E9%99%A4%20-Content-%20%E5%A4%96%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5"><span class="nav-number">4.3.8.</span> <span class="nav-text">示例 7：长度字段包含除 Content 外的多个其他字段</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="牛觅"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">牛觅</p>
  <div class="site-description" itemprop="description">温故知新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">牛觅</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '62cfcbc7db15e27893d3',
      clientSecret: '400600f9989ca757a302e19a03f2c05129c74496',
      repo        : 'blockmao.github.io',
      owner       : 'blockmao',
      admin       : ['blockmao'],
      id          : 'd922e0ca9d3151c16d42703c8e5b1d3d',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
