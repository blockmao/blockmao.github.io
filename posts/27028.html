<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.blockmao.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="JVM：垃圾回收">
<meta property="og:url" content="http://blog.blockmao.cn/posts/27028.html">
<meta property="og:site_name" content="牛觅博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114482420210411144822z46PCb.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210314123046CgpOIF4heVuAPrWVAACK3qrA9-0011.png">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210314133558Cgq2xl4hehyAEx1JAABb83OQ5S0469.png">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210609Ciqah16G0T-AG78xAAFEMVAUqPU670.png">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/20210411144637Ciqah16G0WeAOXhvAAEdzHAK-ss502.png">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210840Cgq2xl4lQueAIYYUAAAXurRIE5I629.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210853CgpOIF4lQueAd1-gAAAfdg7EPJc787.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313212721Cgq2xl4lQueABnuaAABW19PzhdM953.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213017Cgq2xl6G0imALanTAAD5NaTOELA648.png">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213348Cgq2xl4lQuiASUl3AABF6wBEPPY871.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213516Cgq2xl4lQuiAHhjjAAAr3JIdyLA146.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313214140Cgq2xl4lQuiAM7ZPAABnAlb8gZ8269.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313214737CgpOIF4lQuiARGBMAABK3WeyAa4047.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210313215701Cgq2xl4lQuiAHmINAACWihcFScA929.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314111419Cgq2xl4lRrKAQIPzAABOGxOincY196.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314111559CgpOIF4lRrKAF0PnAAB8h8sikiU148.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314112719Cgq2xl4lRrKAep0SAABz3WUkbVs940.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314114256CgpOIF4lSamARPiHAABC8ugXMK8124.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/20210314115205Cgq2xl4lSamAcuN5AAA9uBTIpvw935.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314120215CgpOIF4lSamAXeymAABc7ztdEEU131.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314120828Cgq2xl4lSaqAP6OGAABH2k_Jpog641.jpg">
<meta property="og:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314121853Cgq2xl4lSaqAcPP3AAAel8LUC1s541.jpg">
<meta property="article:published_time" content="2021-04-11T06:46:25.000Z">
<meta property="article:modified_time" content="2021-05-12T03:22:29.921Z">
<meta property="article:author" content="牛觅">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/niumi/drawing/raw/master/2021041114482420210411144822z46PCb.jpg">

<link rel="canonical" href="http://blog.blockmao.cn/posts/27028.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM：垃圾回收 | 牛觅博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a83b1fd818b3df8c1797aa2a2bb38b3e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛觅博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.blockmao.cn/posts/27028.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="牛觅">
      <meta itemprop="description" content="温故知新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛觅博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM：垃圾回收
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 14:46:25" itemprop="dateCreated datePublished" datetime="2021-04-11T14:46:25+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 11:22:29" itemprop="dateModified" datetime="2021-05-12T11:22:29+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114482420210411144822z46PCb.jpg" alt="20210411144822z46PCb"></p>
<span id="more"></span>



<p>虽然 Java 不用“手动管理”内存回收，代码写起来很顺畅。但是你有没有想过，这些内存是怎么被回收的？</p>
<p>其实，JVM 是有专门的线程在做这件事情。当我们的内存空间达到一定条件时，会自动触发。这个过程就叫作 GC，负责 GC 的组件，就叫作垃圾回收器。</p>
<blockquote>
<p>JVM 规范并没有规定垃圾回收器怎么实现，它只需要保证不要把正在使用的对象给回收掉就可以。在现在的服务器环境中，经常被使用的垃圾回收器有 CMS 和 G1，但 JVM 还有其他几个常见的垃圾回收器。</p>
</blockquote>
<p>按照语义上的意思，垃圾回收，首先就需要找到这些垃圾，然后回收掉。<strong>但是 GC 过程正好相反，它是先找到活跃的对象，然后把其他不活跃的对象判定为垃圾，然后删除。所以垃圾回收只与活跃的对象有关，和堆的大小无关</strong>。这个概念是我们一直在强调的，你一定要牢记。</p>
<h2 id="JVM-是如何判断哪些对象应该被回收？"><a href="#JVM-是如何判断哪些对象应该被回收？" class="headerlink" title="JVM 是如何判断哪些对象应该被回收？"></a>JVM 是如何判断哪些对象应该被回收？</h2><ul>
<li><p><strong>引用计数器算法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<blockquote>
<p>主流的Java虚拟机都没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
</blockquote>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，将会被判定为可回收的对象。</p>
<p>如图所示，Obj5、Obj6、Obj7，由于不能和 GC Root 产生关联，发生 GC 时，就会被摧毁。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210314123046CgpOIF4heVuAPrWVAACK3qrA9-0011.png" alt="img"></p>
</li>
</ul>
<h3 id="GC-Roots-有哪些"><a href="#GC-Roots-有哪些" class="headerlink" title="GC Roots 有哪些"></a>GC Roots 有哪些</h3><p>GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。</p>
<p>GC Roots 包括：</p>
<ul>
<li>Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。</li>
<li>所有当前被加载的 Java 类。</li>
<li>Java 类的引用类型静态变量。</li>
<li>运行时常量池里的引用类型常量（String 或 Class 类型）。</li>
<li>JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。</li>
<li>用于同步的监控对象，比如调用了对象的 wait() 方法。</li>
<li>JNI handles，包括 global handles 和 local handles。</li>
</ul>
<p>这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些：</p>
<ul>
<li>活动线程相关的各种引用。</li>
<li>类的静态变量的引用。</li>
<li>JNI 引用。</li>
</ul>
<h2 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h2><p><strong>能够找到 Reference Chain 的对象，就一定会存活么？</strong></p>
<p>对象对于另外一个对象的引用，要看关系牢靠不牢靠，可能在链条的其中一环，就断掉了。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210314133558Cgq2xl4hehyAEx1JAABb83OQ5S0469.png" alt="img"></p>
<p>根据发生 GC 时，这条链条的表现，可以对这个引用关系进行更加细致的划分。它们的关系，可以分为强引用、软引用、弱引用、虚引用等。</p>
<h3 id="强引用-Strong-references"><a href="#强引用-Strong-references" class="headerlink" title="强引用 Strong references"></a>强引用 Strong references</h3><p>当内存空间不足，系统撑不住了，JVM 就会抛出 OutOfMemoryError 错误。即使程序会异常终止，这种对象也不会被回收。这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。</p>
<p>这种引用，你每天的编码都在用。例如：new 一个普通的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object()</span><br></pre></td></tr></table></figure>

<p>这种方式可能是有问题的。假如你的系统被大量用户（User）访问，你需要记录这个 User 访问的时间。可惜的是，User 对象里并没有这个字段，所以我们决定将这些信息额外开辟一个空间进行存放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;User,Long&gt; userVisitMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">userVisitMap.put(user, time);</span><br></pre></td></tr></table></figure>

<p>当你用完了 User 对象，其实你是期望它被回收掉的。但是，由于它被 userVisitMap 引用，我们没有其他手段 remove 掉它。这个时候，就发生了内存泄漏（memory leak）。</p>
<p>这种情况还通常发生在一个没有设定上限的 Cache 系统，由于设置了不正确的引用方式，加上不正确的容量，很容易造成 OOM。</p>
<h3 id="软引用-Soft-references"><a href="#软引用-Soft-references" class="headerlink" title="软引用 Soft references"></a>软引用 Soft references</h3><p>软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p>
<p>可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>软引用需要显式的声明，使用泛型来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> SoftReference(object);</span><br></pre></td></tr></table></figure>

<p>这里有一个相关的 JVM 参数<code>-XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt;</code>。它的意思是：每 MB 堆空闲空间中 SoftReference 的存活时间。这个值的默认时间是1秒（1000）。</p>
<h3 id="弱引用-Weak-references"><a href="#弱引用-Weak-references" class="headerlink" title="弱引用 Weak references"></a>弱引用 Weak references</h3><p>弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。</p>
<p>当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。</p>
<p>它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。它的使用方式类似于这段的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; softRef = <span class="keyword">new</span> WeakReference(object);</span><br></pre></td></tr></table></figure>

<h3 id="虚引用-Phantom-References"><a href="#虚引用-Phantom-References" class="headerlink" title="虚引用 Phantom References"></a>虚引用 Phantom References</h3><p>这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p>实际上，虚引用的 get，总是返回 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object  object = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 虚引用，必须与一个引用队列关联</span></span><br><span class="line">PhantomReference pr = <span class="keyword">new</span> PhantomReference(object, queue);</span><br></pre></td></tr></table></figure>

<p>虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象之前，把这个虚引用加入到与之关联的引用队列中。</p>
<p>程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记（Mark）"><a href="#标记（Mark）" class="headerlink" title="标记（Mark）"></a>标记（Mark）</h3><p>垃圾回收的第一步，就是找出活跃的对象。反复强调 GC 过程是逆向的。</p>
<p>根据 GC Roots 遍历所有的可达对象，这个过程，就叫作标记。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210609Ciqah16G0T-AG78xAAFEMVAUqPU670.png" alt="img"></p>
<blockquote>
<p>圆圈代表的是对象。绿色的代表 GC Roots，红色的代表可以追溯到的对象。可以看到标记之后，仍然有多个灰色的圆圈，它们都是被回收的对象。</p>
</blockquote>
<h3 id="清除（Sweep）"><a href="#清除（Sweep）" class="headerlink" title="清除（Sweep）"></a>清除（Sweep）</h3><p>清除阶段就是把未被标记的对象回收掉。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/20210411144637Ciqah16G0WeAOXhvAAEdzHAK-ss502.png" alt="img"></p>
<p>但是这种简单的清除方式，有一个明显的弊端，那就是碎片问题。</p>
<blockquote>
<p>比如我申请了 1k、2k、3k、4k、5k 的内存。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210840Cgq2xl4lQueAIYYUAAAXurRIE5I629.jpg" alt="img"></p>
<p>由于某种原因 ，2k 和 4k 的内存，我不再使用，就需要交给垃圾回收器回收。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313210853CgpOIF4lQueAd1-gAAAfdg7EPJc787.jpg" alt="img"></p>
<p>这个时候，我应该有足足 6k 的空闲空间。接下来，我打算申请另外一个 5k 的空间，结果系统告诉我内存不足了。系统运行时间越长，这种碎片就越多。</p>
<p>在很久之前使用 Windows 系统时，有一个非常有用的功能，就是内存整理和磁盘整理，运行之后有可能会显著提高系统性能。这个出发点是一样的。</p>
</blockquote>
<h3 id="复制（Copy）"><a href="#复制（Copy）" class="headerlink" title="复制（Copy）"></a>复制（Copy）</h3><p>解决碎片问题没有银弹，只有老老实实的进行内存整理。有一个比较好的思路可以完成这个整理过程，就是提供一个对等的内存空间，将存活的对象复制过去，然后清除原内存空间。</p>
<blockquote>
<p>在程序设计中，一般遇到扩缩容或者碎片整理问题时，复制算法都是非常有效的。比如：HashMap 的扩容也是使用同样的思路，Redis 的 rehash 也是类似的。</p>
</blockquote>
<p>整个过程如图所示：</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313212721Cgq2xl4lQueABnuaAABW19PzhdM953.jpg" alt="img"></p>
<p>这种方式看似非常完美的，解决了碎片问题。但是，它的弊端也非常明显。它浪费了几乎一半的内存空间来做这个事情，如果资源本来就很有限，这就是一种无法容忍的浪费。</p>
<h3 id="整理（Compact）"><a href="#整理（Compact）" class="headerlink" title="整理（Compact）"></a>整理（Compact）</h3><p>其实，不用分配一个对等的额外空间，也是可以完成内存的整理工作。你可以把内存想象成一个非常大的数组，根据随机的 index 删除了一些数据。那么对整个数组的清理，其实是不需要另外一个数组来进行支持的，使用程序就可以实现。</p>
<p><strong>它的主要思路，就是移动所有存活的对象，且按照内存地址顺序依次排列，然后将末端内存地址以后的内存全部回收</strong>。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213017Cgq2xl6G0imALanTAAD5NaTOELA648.png" alt="img"></p>
<p>目前，JVM 的垃圾回收器，都是对几种朴素算法的发扬光大。简单看一下它们的特点：</p>
<ul>
<li><p><strong>复制算法（Copy）</strong></p>
<p>复制算法是所有算法里面效率最高的，缺点是会造成一定的空间浪费。</p>
</li>
<li><p><strong>标记-清除（Mark-Sweep）</strong></p>
<p>效率一般，缺点是会造成内存碎片问题。</p>
</li>
<li><p><strong>标记-整理（Mark-Compact）</strong></p>
<p>效率比前两者要差，但没有空间浪费，也消除了内存碎片问题。</p>
</li>
</ul>
<p>所以，没有最优的算法，只有最合适的算法。</p>
<h2 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h2><p>JVM 是计算节点，而不是存储节点。最理想的情况，就是对象在用完之后，它的生命周期立马就结束了。而那些被频繁访问的资源，希望它能够常驻在内存里。</p>
<p>研究表明，大部分对象，可以分为两类：</p>
<ul>
<li><p>大部分对象的生命周期都很短；</p>
</li>
<li><p>其他对象则很可能会存活很长时间。</p>
</li>
</ul>
<p><strong>大部分死的快，其他的活的长</strong>。这个假设我们称之为<strong>弱代假设（weak generational hypothesis）</strong>。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213348Cgq2xl4lQuiASUl3AABF6wBEPPY871.jpg" alt="img"></p>
<p>现在的垃圾回收器，都会在物理上或者逻辑上，把这两类对象进行区分。我们把死的快的对象所占的区域，叫作年轻代（Young generation）。把其他活的长的对象所占的区域，叫作老年代（Old generation/Tenured Generation）。</p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>年轻代使用的垃圾回收算法是复制算法。因为年轻代发生 GC 后，只会有非常少的对象存活，复制这部分对象是非常高效的。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313213516Cgq2xl4lQuiAHhjjAAAr3JIdyLA146.jpg" alt="img"></p>
<p>如上图所示，年轻代分为：一个伊甸园空间（Eden ），两个幸存者空间（Survivor ）。</p>
<p>当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：</p>
<ul>
<li><p>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（以下简称from）；</p>
</li>
<li><p>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理。存活的对象会被复制到 to 区；接下来，只需要清空 from 区就可以了。</p>
</li>
</ul>
<p>所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、from、to 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。这个比例，是由参数 -XX:SurvivorRatio 进行配置的（默认为 8）。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代一般使用“标记-清除”、“标记-整理”算法，因为老年代的对象存活率一般是比较高的，空间又比较大，拷贝起来并不划算，还不如采取就地收集的方式。</p>
<p><strong>对象是怎么进入老年代的呢</strong>？有多种途径。</p>
<ol>
<li><strong>提升（Promotion）</strong></li>
</ol>
<p>如果对象够老，会通过“提升”进入老年代。</p>
<p>关于对象老不老，是通过它的年龄（age）来判断的。每当发生一次 Minor GC，存活下来的对象年龄都会加 1。直到达到一定的阈值，就会把这些“老顽固”给提升到老年代。</p>
<p>这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。</p>
<blockquote>
<p>这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15，因为它是用 4bit 存储的。</p>
</blockquote>
<ol start="2">
<li><strong>分配担保</strong></li>
</ol>
<p>看一下年轻代的图，每次存活的对象，都会放入其中一个幸存区，这个区域默认的比例是 10%。但是我们无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。</p>
<ol start="3">
<li><strong>大对象直接在老年代分配</strong></li>
</ol>
<p>超出某个大小的对象将直接在老年代分配。这个值是通过参数 <code>-XX:PretenureSizeThreshold</code> 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。</p>
<ol start="4">
<li><strong>动态对象年龄判定</strong></li>
</ol>
<p>有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，如果幸存区中相同年龄对象大小的和，大于幸存区的一半，大于或等于 age 的对象将会直接进入老年代。</p>
<p>这些动态判定一般不受外部控制，我们知道有这么回事就可以了。通过下图可以看一下一个对象的分配逻辑。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313214140Cgq2xl4lQuiAM7ZPAABnAlb8gZ8269.jpg" alt="img"></p>
<h3 id="卡片标记（card-marking）"><a href="#卡片标记（card-marking）" class="headerlink" title="卡片标记（card marking）"></a>卡片标记（card marking）</h3><p>对象的引用关系是一个巨大的网状。有的对象可能在 Eden 区，有的可能在老年代，那么这种跨代的引用是如何处理的呢？<strong>由于 Minor GC 是单独发生的，如果一个老年代的对象引用了它，如何确保能够让年轻代的对象存活呢</strong>？</p>
<p>对于是、否的判断，我们通常都会用 Bitmap（位图）和布隆过滤器来加快搜索的速度。JVM 也是用了类似的方法。其实，老年代是被分成众多的卡页（card page）的（一般数量是 2 的次幂）。</p>
<p>卡表（Card Table）就是用于标记卡页状态的一个集合，每个卡表项对应一个卡页。</p>
<p><strong>如果年轻代有对象分配，而且老年代有对象指向这个新对象， 那么这个老年代对象所对应内存的卡页，就会标识为 dirty，卡表只需要非常小的存储空间就可以保留这些状态</strong>。</p>
<p>垃圾回收时，就可以先读这个卡表，进行快速判断。</p>
<h2 id="HotSpot-垃圾回收器"><a href="#HotSpot-垃圾回收器" class="headerlink" title="HotSpot 垃圾回收器"></a>HotSpot 垃圾回收器</h2><p>每种回收器都有各自的特点。我们在平常的 GC 优化时，一定要搞清楚现在用的是哪种垃圾回收器。</p>
<p> <img src="https://gitee.com/niumi/drawing/raw/master/2021041114463720210313214737CgpOIF4lQuiARGBMAABK3WeyAa4047.jpg" alt="img"></p>
<h3 id="年轻代垃圾回收器"><a href="#年轻代垃圾回收器" class="headerlink" title="年轻代垃圾回收器"></a>年轻代垃圾回收器</h3><ol>
<li><strong>Serial 垃圾收集器</strong></li>
</ol>
<p>处理 GC 的只有一条线程，并且在垃圾回收的过程中暂停一切用户线程。</p>
<p>可以说是最简单的垃圾回收器，但千万别以为它没有用武之地。因为简单，所以高效，它通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。</p>
<ol start="2">
<li><strong>ParNew 垃圾收集器</strong></li>
</ol>
<p>ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。清理过程依然要停止用户线程。</p>
<p>ParNew 追求“低停顿时间”，与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。</p>
<p>3.<strong>Parallel Scavenge 垃圾收集器</strong></p>
<p>另一个多线程版本的垃圾回收器。它与 ParNew 的主要区别是：</p>
<ul>
<li><p>Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。弱交互强计算。</p>
</li>
<li><p>ParNew：追求降低用户停顿时间，适合交互式应用。强交互弱计算。</p>
</li>
</ul>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><ol>
<li><strong>Serial Old 垃圾收集器</strong></li>
</ol>
<p>与年轻代的 Serial 垃圾收集器对应，都是单线程版本，同样适合客户端使用。</p>
<blockquote>
<p>年轻代的 Serial，使用复制算法。</p>
<p>老年代的 Old Serial，使用标记-整理算法。</p>
</blockquote>
<ol start="2">
<li><strong>Parallel Old</strong></li>
</ol>
<p>Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</p>
<ol start="3">
<li><strong>CMS 垃圾收集器</strong></li>
</ol>
<p>CMS（Concurrent Mark Sweep）收集器是以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>除了上面几个垃圾回收器，还有 G1、ZGC 等更加高级的垃圾回收器，它们都有专门的配置参数来使其生效。</p>
<p>通过 <code>-XX:+PrintCommandLineFlags</code> 参数，可以查看当前 Java 版本默认使用的垃圾回收器。</p>
<p>以下是一些配置参数：</p>
<ul>
<li><p><code>-XX:+UseSerialGC</code> 年轻代和老年代都用串行收集器</p>
</li>
<li><p><code>-XX:+UseParNewGC</code> 年轻代使用 ParNew，老年代使用 Serial Old</p>
</li>
<li><p><code>-XX:+UseParallelGC</code> 年轻代使用 ParallerGC，老年代使用 Serial Old</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code> 新生代和老年代都使用并行收集器</p>
</li>
<li><p><code>-XX:+UseConcMarkSweepGC</code>，表示年轻代使用 ParNew，老年代的用 CMS</p>
</li>
<li><p><code>-XX:+UseG1GC</code> 使用 G1垃圾回收器</p>
</li>
<li><p><code>-XX:+UseZGC</code> 使用 ZGC 垃圾回收器</p>
</li>
</ul>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210313215701Cgq2xl4lQuiAHmINAACWihcFScA929.jpg" alt="img"></p>
<p>注意 -XX:+UseParNewGC 这个参数，已经在 Java9 中就被抛弃了。很多程序（比如 ES）会报这个错误，不要感到奇怪。</p>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>CMS 的全称是 Mostly Concurrent Mark and Sweep Garbage Collector（主要并发­标记­清除­垃圾收集器），它在年轻代使用复制算法，而对老年代使用标记-清除算法。你可以看到，在老年代阶段，比起 Mark-Sweep，它多了一个并发字样。</p>
<p>CMS 的设计目标，是避免在老年代 GC 时出现长时间的卡顿（但它并不是一个老年代回收器）。如果你不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，使用 CMS 是比较合适的。</p>
<h3 id="CMS垃圾回收过程"><a href="#CMS垃圾回收过程" class="headerlink" title="CMS垃圾回收过程"></a>CMS垃圾回收过程</h3><h4 id="初始标记（Initial-Mark）"><a href="#初始标记（Initial-Mark）" class="headerlink" title="初始标记（Initial Mark）"></a>初始标记（Initial Mark）</h4><p>初始标记阶段，只标记直接关联 GC root 的对象，不用向下追溯。因为最耗时的就在 tracing 阶段，这样就极大地缩短了初始标记时间。</p>
<p>这个过程是 STW 的，但由于只是标记第一层，所以速度是很快的。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314111419Cgq2xl4lRrKAQIPzAABOGxOincY196.jpg" alt="img"></p>
<p>注意，这里<strong>除了要标记相关的 GC Roots 之外，还要标记年轻代中对象的引用</strong>，这也是 CMS 老年代回收，依然要扫描新生代的原因。</p>
<h4 id="并发标记（Concurrent-Mark）"><a href="#并发标记（Concurrent-Mark）" class="headerlink" title="并发标记（Concurrent Mark）"></a>并发标记（Concurrent Mark）</h4><p>在初始标记的基础上，进行并发标记。这一步骤主要是 tracinng 的过程，用于标记所有可达的对象。</p>
<p>这个过程会持续比较长的时间，但却可以和用户线程并行。在这个阶段的执行过程中，可能会产生很多变化：</p>
<ul>
<li><p>有些对象，从新生代晋升到了老年代；</p>
</li>
<li><p>有些对象，直接分配到了老年代；</p>
</li>
<li><p>老年代或者新生代的对象引用发生了变化。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314111559CgpOIF4lRrKAF0PnAAB8h8sikiU148.jpg" alt="img"></p>
</li>
</ul>
<p>在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。</p>
<h4 id="并发预清理（Concurrent-Preclean）"><a href="#并发预清理（Concurrent-Preclean）" class="headerlink" title="并发预清理（Concurrent Preclean）"></a>并发预清理（Concurrent Preclean）</h4><p>并发预清理也是不需要 STW 的，目的是为了让重新标记阶段的 STW 尽可能短。这个时候，老年代中被标记为 dirty 的卡页中的对象，就会被重新标记，然后清除掉 dirty 的状态。</p>
<p>由于这个阶段也是可以并发的，在执行过程中引用关系依然会发生一些变化。我们可以假定这个清理动作是第一次清理。</p>
<p>所以重新标记阶段，有可能还会有处于 dirty 状态的卡页。</p>
<h4 id="并发可取消的预清理（Concurrent-Abortable-Preclean）"><a href="#并发可取消的预清理（Concurrent-Abortable-Preclean）" class="headerlink" title="并发可取消的预清理（Concurrent Abortable Preclean）"></a>并发可取消的预清理（Concurrent Abortable Preclean）</h4><p>因为重新标记是需要 STW 的，所以会有很多次预清理动作。并发可取消的预清理，顾名思义，在满足某些条件的时候，可以终止，比如迭代次数、有用工作量、消耗的系统时间等。</p>
<p><strong>这个阶段是可选的。换句话说，这个阶段是“并发预清理”阶段的一种优化</strong>。</p>
<p>这个阶段的第一个意图，是避免回扫年轻代的大量对象；另外一个意图，就是当满足最终标记的条件时，自动退出。</p>
<p>标记动作是需要扫描年轻代的。如果年轻代的对象太多，肯定会严重影响标记的时间。如果在此之前能够进行一次 Minor GC，情况会不会变得好了许多？</p>
<p>CMS 提供了参数 CMSScavengeBeforeRemark，可以在进入重新标记之前强制进行一次 Minor GC。</p>
<p>但请你记住一件事情，GC 的停顿是不分什么年轻代老年代的。设置了上面的参数，可能会在一个比较长的 Minor GC 之后，紧跟着一个 CMS 的 Remark，它们都是 STW 的。</p>
<h4 id="最终标记（Final-Remark）"><a href="#最终标记（Final-Remark）" class="headerlink" title="最终标记（Final Remark）"></a>最终标记（Final Remark）</h4><p>通常 CMS 会尝试在年轻代尽可能空的情况下运行 Final Remark 阶段，以免接连多次发生 STW 事件。</p>
<p><strong>这是 CMS 垃圾回收阶段的第二次 STW 阶段，目标是完成老年代中所有存活对象的标记。</strong>前面多轮的 preclean 阶段，一直在和应用线程玩追赶游戏，有可能跟不上引用的变化速度。本轮的标记动作就需要 STW 来处理这些情况。</p>
<p>如果预处理阶段做的不够好，会显著增加本阶段的 STW 时间。你可以看到，CMS 垃圾回收器把回收过程分了多个部分，而影响最大的不是 STW 阶段本身，而是它之前的预处理动作。</p>
<h4 id="并发清除（Concurrent-Sweep）"><a href="#并发清除（Concurrent-Sweep）" class="headerlink" title="并发清除（Concurrent Sweep）"></a>并发清除（Concurrent Sweep）</h4><p>此阶段用户线程被重新激活，目标是删掉不可达的对象，并回收它们的空间。</p>
<p>由于 CMS 并发清理阶段用户线程还在运行中，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次 GC 中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314112719Cgq2xl4lRrKAep0SAABz3WUkbVs940.jpg" alt="img"></p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>由于 CMS 在执行过程中，用户线程还需要运行，那就需要保证有充足的内存空间供用户使用。如果等到老年代空间快满了，再开启这个回收过程，用户线程可能会产生“Concurrent Mode Failure”的错误，这时会临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了（STW）。</p>
<p>这部分空间预留，一般在 30% 左右即可，那么能用的大概只有 70%。参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 用来配置这个比例（记得要首先开启参数<code>UseCMSInitiatingOccupancyOnly</code>）。也就是说，当老年代的使用率达到 70%，就会触发 GC 了。如果你的系统老年代增长不是太快，可以调高这个参数，降低内存回收的次数。这个比率非常不好设置。一般在堆大小小于 2GB 的时候，都不会考虑 CMS 垃圾回收器。</p>
<p>另外，CMS 对老年代回收的时候，并没有内存的整理阶段。这就造成程序在长时间运行之后，碎片太多。如果你申请一个稍大的对象，就会引起分配失败。</p>
<p>CMS 提供了两个参数来解决这个问题：</p>
<p>（1） <code>UseCMSCompactAtFullCollection</code>（默认开启），表示在要进行 Full GC 的时候，进行内存碎片整理。内存整理的过程是无法并发的，所以停顿时间会变长。</p>
<p>（2）<code>CMSFullGCsBeforeCompaction</code>，每隔多少次不压缩的 Full GC 后，执行一次带压缩的 Full GC。默认值为 0，表示每次进入 Full GC 时都进行碎片整理。</p>
<p>所以，预留空间加上内存的碎片，使用 CMS 垃圾回收器的老年代，留给我们的空间就不是太多，这也是 CMS 的一个弱点。</p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1 的全称是 Garbage­First GC，</p>
<h3 id="G1分代"><a href="#G1分代" class="headerlink" title="G1分代"></a>G1分代</h3><p>其他的回收器，都是对某个年代的整体收集，收集时间上自然不好控制。G1 把堆切成了很多份，把每一份当作一个小目标，部分上目标很容易达成。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314114256CgpOIF4lSamARPiHAABC8ugXMK8124.jpg" alt="img"></p>
<p>如图所示，G1 也是有 Eden 区和 Survivor 区的概念的，只不过它们在内存上不是连续的，而是由一小份一小份组成的。</p>
<p>这一小份区域的大小是固定的，名字叫作小堆区（Region）。小堆区可以是 Eden 区，也可以是 Survivor 区，还可以是 Old 区。所以 G1 的年轻代和老年代的概念都是逻辑上的。每一块 Region，大小都是一致的，它的数值是在 1M 到 32M 字节之间的一个 2 的幂值数。</p>
<p>但假如我的对象太大，一个 Region 放不下了怎么办？注意图中有一块面积很大的黄色区域，它的名字叫作 Humongous Region，大小超过 Region 50% 的对象，将会在这里分配。</p>
<blockquote>
<p>Region 的大小，可以通过参数进行设置：</p>
<p><code>-XX:G1HeapRegionSize=&lt;N&gt;M</code></p>
<p>那么，回收的时候，到底回收哪些小堆区呢？是随机的么？</p>
<p>这当然不是。事实上，垃圾最多的小堆区，会被优先收集。这就是 G1 名字的由来。</p>
</blockquote>
<h3 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h3><p>在逻辑上，G1 分为年轻代和老年代，但它的年轻代和老年代比例，并不是那么“固定”，为了达到 MaxGCPauseMillis 所规定的效果，G1 会自动调整两者之间的比例。</p>
<p>如果你强行使用 <code>-Xmn</code> 或者 <code>-XX:NewRatio</code> 去设定它们的比例的话，我们给 G1 设定的这个目标将会失效。</p>
<p>G1 的回收过程主要分为 3 类：</p>
<p>（1）G1“年轻代”的垃圾回收，同样叫 Minor GC，发生时机就是 Eden 区满的时候。</p>
<p>（2）老年代的垃圾收集，严格上来说其实不算是收集，它是一个“并发标记”的过程，顺便清理了一点点对象。</p>
<p>（3）真正的清理，发生在“混合模式”，它不止清理年轻代，还会将老年代的一部分区域进行清理。</p>
<img src="https://gitee.com/niumi/drawing/raw/master/20210314115205Cgq2xl4lSamAcuN5AAA9uBTIpvw935.jpg" alt="img" style="zoom: 67%;" />

<p>在 GC 日志里，这个过程描述特别有意思，（1）的过程，叫作 <code>[GC pause (G1 Evacuation Pause) (young)</code>，而（2）的过程，叫作 <code>[GC pause (G1 Evacuation Pause) (mixed)</code>。Evacuation 是转移的意思，和 Copy 的意思有点类似。</p>
<p>这三种模式之间的间隔也是不固定的。比如，1 次 Minor GC 后，发生了一次并发标记，接着发生了 9 次 Mixed GC。</p>
<h4 id="RSet"><a href="#RSet" class="headerlink" title="RSet"></a>RSet</h4><p>RSet 全称是 Remembered Set，是一个空间换时间的数据结构（与<code>Card Table</code>功能类似），用于记录和维护 Region 之间的对象引用关系。</p>
<p>但 RSet 与 Card Table 有些不同的地方。Card Table 是一种 points-out（我引用了谁的对象）的结构。而 RSet 记录了其他 Region 中的对象引用本 Region 中对象的关系，属于 points-into 结构（谁引用了我的对象），有点倒排索引的味道。</p>
<p>你可以把 RSet 理解成一个 Hash，key 是引用的 Region 地址，value 是引用它的对象的卡页集合。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314120215CgpOIF4lSamAXeymAABc7ztdEEU131.jpg" alt="img"></p>
<p>对于年轻代的 Region，它的 RSet 只保存了来自老年代的引用，这是因为年轻代的回收是针对所有年轻代 Region 的，没必要画蛇添足。所以说年轻代 Region 的 RSet 有可能是空的。</p>
<p>而对于老年代的 Region 来说，它的 RSet 也只会保存老年代对它的引用。这是因为老年代回收之前，会先对年轻代进行回收。这时，Eden 区变空了，而在回收过程中会扫描 Survivor 分区，所以也没必要保存来自年轻代的引用。</p>
<p>RSet 通常会占用很大的空间，大约 5% 或者更高。不仅仅是空间方面，很多计算开销也是比较大的。</p>
<p>事实上，为了维护 RSet，程序运行的过程中，写入某个字段就会产生一个 post-write barrier 。为了减少这个开销，将内容放入 RSet 的过程是异步的，而且经过了很多的优化：Write Barrier 把脏卡信息存放到本地缓冲区（local buffer），有专门的 GC 线程负责收集，并将相关信息传给被引用 Region 的 RSet。</p>
<p>参数 <code>-XX:G1ConcRefinementThreads</code> 或者 <code>-XX:ParallelGCThreads</code> 可以控制这个异步的过程。如果并发优化线程跟不上缓冲区的速度，就会在用户进程上完成。</p>
<h4 id="年轻代回收"><a href="#年轻代回收" class="headerlink" title="年轻代回收"></a>年轻代回收</h4><p>年轻代回收是一个 STW 的过程，它的跨代引用使用 RSet 数据结构来追溯，会一次性回收掉年轻代的所有 Region。</p>
<p>JVM 启动时，G1 会先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当所有的 Eden 区都满了，G1 会启动一次年轻代垃圾回收过程。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314120828Cgq2xl4lSaqAP6OGAABH2k_Jpog641.jpg" alt="img"></p>
<p>年轻代的收集包括下面的回收阶段：</p>
<ol>
<li><p><strong>扫描根</strong></p>
<p> 根，可以看作是我们前面介绍的 GC Roots，加上 RSet 记录的其他 Region 的外部引用。</p>
</li>
<li><p><strong>更新 RS</strong></p>
<p>处理 dirty card queue 中的卡页，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。可以看作是第一步的补充。</p>
</li>
<li><p><strong>处理 RS</strong></p>
<p>识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p>
</li>
<li><p><strong>复制对象</strong></p>
<p>没错，收集算法依然使用的是 Copy 算法。</p>
<p>在这个阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的 Region。这个过程和其他垃圾回收算法一样，包括对象的年龄和晋升，无需做过多介绍。</p>
</li>
<li><p><strong>处理引用</strong></p>
<p>处理 Soft、Weak、Phantom、Final、JNI Weak 等引用。结束收集。</p>
</li>
</ol>
<h4 id="并发标记（Concurrent-Marking）"><a href="#并发标记（Concurrent-Marking）" class="headerlink" title="并发标记（Concurrent Marking）"></a>并发标记（Concurrent Marking）</h4><p>当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动。这个比例也是可以调整的，通过参数 <code>-XX:InitiatingHeapOccupancyPercent</code> 进行配置。</p>
<p>Concurrent Marking 是为 Mixed GC 提供标记服务的，并不是一次 GC 过程的一个必须环节。这个过程和 CMS 垃圾回收器的回收过程非常类似，具体标记过程如下：</p>
<ol>
<li><p><strong>初始标记（Initial Mark）</strong></p>
<p>这个过程共用了 Minor GC 的暂停，这是因为它们可以复用 root scan 操作。虽然是 STW 的，但是时间通常非常短。</p>
</li>
<li><p><strong>Root 区扫描（Root Region Scan）</strong></p>
</li>
<li><p><strong>并发标记（ Concurrent Mark）</strong></p>
<p>这个阶段从 GC Roots 开始对 heap 中的对象标记，标记线程与应用程序线程并行执行，并且收集各个 Region 的存活对象信息。</p>
</li>
<li><p><strong>重新标记（Remaking）</strong></p>
<p>和 CMS 类似，也是 STW 的。标记那些在并发标记阶段发生变化的对象。</p>
</li>
<li><p><strong>清理阶段（Cleanup）</strong></p>
<p>这个过程不需要 STW。如果发现 Region 里全是垃圾，在这个阶段会立马被清除掉。不全是垃圾的 Region，并不会被立马处理，它会在 Mixed GC 阶段，进行收集。</p>
</li>
</ol>
<blockquote>
<p>如果在并发标记阶段，又有新的对象变化，该怎么办？</p>
<p>这是由算法 SATB 保证的。SATB 的全称是 Snapshot At The Beginning，它作用是保证在并发标记阶段的正确性。</p>
<p><img src="https://gitee.com/niumi/drawing/raw/master/2021041114463820210314121853Cgq2xl4lSaqAcPP3AAAel8LUC1s541.jpg" alt="img"></p>
<p>这个快照是逻辑上的，主要是有几个指针，将 Region 分成个多个区段。如图所示，并发标记期间分配的对象，都会在 next TAMS 和 top 之间。</p>
</blockquote>
<h4 id="混合回收（Mixed-GC）"><a href="#混合回收（Mixed-GC）" class="headerlink" title="混合回收（Mixed GC）"></a>混合回收（Mixed GC）</h4><p>能并发清理老年代中的整个整个的小堆区是一种最优情形。混合收集过程，不只清理年轻代，还会将一部分老年代区域也加入到 CSet 中。</p>
<p>通过 Concurrent Marking 阶段，已经统计了老年代的垃圾占比。在 Minor GC 之后，如果判断这个占比达到了某个阈值，下次就会触发 Mixed GC。这个阈值，由 <code>-XX:G1HeapWastePercent</code> 参数进行设置（默认是堆大小的 5%）。因为这种情况下， GC 会花费很多的时间但是回收到的内存却很少。所以这个参数也是可以调整 Mixed GC 的频率的。</p>
<p>还有参数 <code>G1MixedGCCountTarget</code>，用于控制一次并发标记之后，最多执行 Mixed GC 的次数。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/4844.html" rel="prev" title="Java并发编程：Lock（锁）">
      <i class="fa fa-chevron-left"></i> Java并发编程：Lock（锁）
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/35904.html" rel="next" title="Java并发编程：ThreadLocal">
      Java并发编程：ThreadLocal <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%BA%94%E8%AF%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">JVM 是如何判断哪些对象应该被回收？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-Roots-%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.1.</span> <span class="nav-text">GC Roots 有哪些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">引用级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-Strong-references"><span class="nav-number">2.1.</span> <span class="nav-text">强引用 Strong references</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-references"><span class="nav-number">2.2.</span> <span class="nav-text">软引用 Soft references</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-references"><span class="nav-number">2.3.</span> <span class="nav-text">弱引用 Weak references</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-References"><span class="nav-number">2.4.</span> <span class="nav-text">虚引用 Phantom References</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%EF%BC%88Mark%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">标记（Mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%EF%BC%88Sweep%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">清除（Sweep）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%88Copy%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">复制（Copy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E7%90%86%EF%BC%88Compact%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">整理（Compact）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3"><span class="nav-number">4.</span> <span class="nav-text">分代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3"><span class="nav-number">4.1.</span> <span class="nav-text">年轻代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">4.2.</span> <span class="nav-text">老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A1%E7%89%87%E6%A0%87%E8%AE%B0%EF%BC%88card-marking%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">卡片标记（card marking）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">HotSpot 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">年轻代垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">老年代垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">配置参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS"><span class="nav-number">6.</span> <span class="nav-text">CMS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">CMS垃圾回收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88Initial-Mark%EF%BC%89"><span class="nav-number">6.1.1.</span> <span class="nav-text">初始标记（Initial Mark）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Mark%EF%BC%89"><span class="nav-number">6.1.2.</span> <span class="nav-text">并发标记（Concurrent Mark）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%A2%84%E6%B8%85%E7%90%86%EF%BC%88Concurrent-Preclean%EF%BC%89"><span class="nav-number">6.1.3.</span> <span class="nav-text">并发预清理（Concurrent Preclean）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E9%A2%84%E6%B8%85%E7%90%86%EF%BC%88Concurrent-Abortable-Preclean%EF%BC%89"><span class="nav-number">6.1.4.</span> <span class="nav-text">并发可取消的预清理（Concurrent Abortable Preclean）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0%EF%BC%88Final-Remark%EF%BC%89"><span class="nav-number">6.1.5.</span> <span class="nav-text">最终标记（Final Remark）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4%EF%BC%88Concurrent-Sweep%EF%BC%89"><span class="nav-number">6.1.6.</span> <span class="nav-text">并发清除（Concurrent Sweep）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">6.2.</span> <span class="nav-text">内存碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1"><span class="nav-number">7.</span> <span class="nav-text">G1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%88%86%E4%BB%A3"><span class="nav-number">7.1.</span> <span class="nav-text">G1分代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">G1垃圾回收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RSet"><span class="nav-number">7.2.1.</span> <span class="nav-text">RSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="nav-number">7.2.2.</span> <span class="nav-text">年轻代回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Marking%EF%BC%89"><span class="nav-number">7.2.3.</span> <span class="nav-text">并发标记（Concurrent Marking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6%EF%BC%88Mixed-GC%EF%BC%89"><span class="nav-number">7.2.4.</span> <span class="nav-text">混合回收（Mixed GC）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="牛觅"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">牛觅</p>
  <div class="site-description" itemprop="description">温故知新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">牛觅</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '62cfcbc7db15e27893d3',
      clientSecret: '400600f9989ca757a302e19a03f2c05129c74496',
      repo        : 'blockmao.github.io',
      owner       : 'blockmao',
      admin       : ['blockmao'],
      id          : '1a1c5929acce05a1be105133299680d5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
